
060621 putEvent:

Anyways, it provides a good stress test of Lablib because there's a lot of data flying around. And the latest 
snafu is with putEvent. Currently the data acquisition loops call putEvent and everything is usually fine and 
dandy. But there's a problem if putEvent actually takes a decent amount of time (specifically larger than the 
sampling interval).  For example, I want to run my 16-bit, 512x512 camera at 40 Hz. It turns out that putEvent 
is taking about 30 ms to handle a frame, and so the frame rate is down  to 20 Hz. (When I comment out  putEvent, 
I get the higher rate).

One obvious solution is to detach a thread so that the data collection loop isn't waiting around for the 
putEvents to complete. The cleanest place to do this would be within LLDataDoc, with eventToBuffer taking an 
single object with all of the relevant arguments (code, pData,bytes,and writeLength).  Then it would be simply 
a matter of having all the putEvent methods do something like:

[NSThread detachNewThreadSelector:@selector(eventToBuffer:) toTarget:self withObject:anEvent];

Given the locks it should be safe, but of course I'm little worried about mucking around at this level. The 
other issue is that all this thread stuff is likely to overkill for most events which are reasonably sized. So 
I was thinking it might make sense to keep the current methods, and add threaded versions (threadedPutEvent?)

Opinions? Words of wisdom?


060330 LLGabor:

I decided to celebrate getting a paper accepted by fixing a long standing problem with the Gabor code. 
(Pretty sad sense of fun, huh?)

The problem was the circular aperture was never done correctly. Although the grating was truncated to a 
circle, there was still an entire square gray background left behind, and this became a real problem when 
multiple Gabors were put near each other.

The correct way is to use the stencil plane, and that's what the enclosed code does. Not only is it the 
"right way", I think it's also slightly faster than using texturing (which is really designed for more 
sophisticated operations than masking). And the code is cleaner because it's doesn't  have to check for 
the number of texture units available (the circle is drawn using a displaylist, not a texture).

The code is pretty much plug and play with two caveats:

when the GL window is initialized, you need to stake out some stencil bits

So

    NSOpenGLPixelFormatAttribute windowedAttrib[] = {
        NSOpenGLPFANoRecovery, NSOpenGLPFAAccelerated, NSOpenGLPFADoubleBuffer,
        NSOpenGLPFAColorSize, (NSOpenGLPixelFormatAttribute) 24,
        NSOpenGLPFAAlphaSize, (NSOpenGLPixelFormatAttribute) 8,
        NSOpenGLPFADepthSize, (NSOpenGLPixelFormatAttribute) 0,
        NSOpenGLPFAStencilSize, (NSOpenGLPixelFormatAttribute) 0,
        NSOpenGLPFAAccumSize, (NSOpenGLPixelFormatAttribute) 0,
        NSOpenGLPFAWindow, (NSOpenGLPixelFormatAttribute) 0
    };

becomes

    NSOpenGLPixelFormatAttribute windowedAttrib[] = {
        NSOpenGLPFANoRecovery, NSOpenGLPFAAccelerated, NSOpenGLPFADoubleBuffer,
        NSOpenGLPFAColorSize, (NSOpenGLPixelFormatAttribute) 24,
        NSOpenGLPFAAlphaSize, (NSOpenGLPixelFormatAttribute) 8,
        NSOpenGLPFADepthSize, (NSOpenGLPixelFormatAttribute) 0,
        NSOpenGLPFAStencilSize, (NSOpenGLPixelFormatAttribute) 8,
        NSOpenGLPFAAccumSize, (NSOpenGLPixelFormatAttribute) 0,
        NSOpenGLPFAWindow, (NSOpenGLPixelFormatAttribute) 0
    };


I've specified 8 even though I only use 1 bit, because every openGL card I've seen has hardware support for 
8 bpp and not 1 bpp.

The only other change is to make sure than when you call glClear you clear the stencil buffer as well:

    glClear(GL_COLOR_BUFFER_BIT);

becomes

    glClear(GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);


That's it.

I didn't bother changing the random dots code, but I think what I did was clear enough, and I can go 
ahead and do that if you you'd like.


Also I have a suggestion (semi bug fix) for LLStimWindow: I think the unlock method should flushBuffer. 
That way you don't have to worry about sending openGL commands and not having them actually appear! 
This requires the grayScreen method to NOT flushBuffer, otherwise you've got a big black screen when 
you start a program (from double flushing).


The reason this came up is I did a [fixSpot draw], and it wasn't doing anything.

Here's the code for the Gabor. Enjoy!:
